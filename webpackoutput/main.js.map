{"version":3,"file":"main.js","mappings":";;;;;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClLsC;AACtC;AACe;AACf;AACA;AACA,UAAU,mBAAmB;AAC7B;AACA,SAAS,mBAAmB;AAC5B,MAAM,mBAAmB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mBAAmB;AAC5B,SAAS,mBAAmB;AAC5B,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO,IAAI,SAAS,IAAI,SAAS,IAAI,cAAc;AAClE;AACA;AACA;AACA,UAAU,4BAA4B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA,UAAU,mBAAmB;AAC7B;AACA;AACA;AACA;AACA,UAAU,oBAAoB;AAC9B;AACA;AACA;AACA,SAAS,oBAAoB;AAC7B;AACA,SAAS,mBAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B;AACA,UAAU,mBAAmB;AAC7B,UAAU,oBAAoB;AAC9B;AACA,SAAS,0BAA0B;AACnC;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7FsC;AACR;AAC9B;AACe;AACf;AACA;AACA,UAAU,mBAAmB;AAC7B,MAAM,qBAAqB;AAC3B;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA,+BAA+B,gCACC;AAChC,UAAU,qBAAqB;AAC/B;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+BACL;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B,MAAM,qBAAqB;AAC3B;AACA,YAAY,gCAAgC;AAC5C,SAAS,gBAAgB;AACzB;AACA,SAAS,qBAAqB;AAC9B;AACA;AACA;AACA,kCAAkC,+BACL;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B,UAAU,mBAAmB;AAC7B,OAAO,qBAAqB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gCAAgC;AACtD,oCAAoC,qBAAqB;AACzD;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B,MAAM,gBAAgB;AACtB;AACA;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B,MAAM,qBAAqB;AAC3B;AACA,aAAa,wBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,gCAAgC;AACtC,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA,iBAAiB,wBACM;AACvB;AACA,QAAQ;AACR;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,UAAU,gCAAgC;AAC1C;AACA,UAAU,kBAAkB;AAC5B;AACA;AACA;AACA;AACA;;AC9H8B;AACQ;AACR;AAC9B;AACe;AACf;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,UAAU,mBAAmB;AAC7B;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,UAAU,mBAAmB;AAC7B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,UAAU,mBAAmB;AAC7B;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA,UAAU,qBAAqB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,UAAU,mBAAmB;AAC7B;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,+BAA+B,oCAAoC;AACnE;AACA;AACA;AACA;AACA,MAAM;AACN,UAAU,mBAAmB;AAC7B;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B,OAAO,mBAAmB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B;AACA,MAAM,qBAAqB;AAC3B;AACA;AACA;;AClK8B;AACQ;AACR;AAC9B;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,UAAU,mBAAmB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,UAAU,mBAAmB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,UAAU,mBAAmB;AAC7B;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,UAAU,qBAAqB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,+BAA+B,oCAAoC;AACnE;AACA;AACA;AACA;AACA,MAAM;AACN,UAAU,mBAAmB;AAC7B;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B,OAAO,mBAAmB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B,OAAO,mBAAmB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B,OAAO,mBAAmB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B,WAAW,qBAAqB;AAChC;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B;AACA,OAAO,qBAAqB;AAC5B;AACA;AACA;;AC/PsC;AACR;AAC8B;AACc;AACR;AAClE;AACe;AACf;AACA;AACA,SAAS,gCAAgC;AACzC;AACA;AACA,SAAS,qBAAqB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B,SAAS,gCAAgC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B,aAAa,YAAY;AACzB,UAAU,qBAAqB;AAC/B,aAAa,YAAY;AACzB;AACA,sBAAsB,mBAAmB;AACzC;AACA,MAAM,sCAAsC;AAC5C,MAAM,oCAAoC;AAC1C;AACA;AACA,+CAA+C,sFACiB;AAChE;AACA;AACA;AACA,QAAQ;AACR,6CAA6C,gFACiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B,aAAa,YAAY;AACzB,UAAU,gCAAgC;AAC1C,aAAa,YAAY;AACzB;AACA,sBAAsB,mBAAmB;AACzC;AACA,MAAM,sCAAsC;AAC5C,MAAM,oCAAoC;AAC1C;AACA;AACA,+CAA+C,qFACgB;AAC/D;AACA;AACA;AACA,QAAQ;AACR,6CAA6C,+EACgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,qBAAqB;AAC5B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,UAAU,mBAAmB;AAC7B,OAAO,mBAAmB;AAC1B,OAAO,mBAAmB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY,mBAAmB,eAAe;AAC7D;AACA;AACA,MAAM;AACN,aAAa,YAAY,oCAAoC,cAAc;AAC3E;AACA;AACA;AACA;AACA;;AC7HO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDmC;AAGhB;AACnB;AACO,wBAAwB,KAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,YAAY;AAChB;AACA;AACA;;ACzC8B;AACQ;AACtC;AACe;AACf;AACA;AACA,SAAS,mBAAmB;AAC5B,MAAM,yBAAyB;AAC/B;AACA;AACA;;ACVyC;AACzC;AACe,kCAAkC,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBmC;AACM;AACE;AACR;AAGhB;AACa;AACY;AACJ;AACuC;AACvB;AACxD;AACA,2BAA2B,OAAO;AAClC;AACO,iCAAiC,OAAO;AAC/C;AACA;AACA,IAAI,YAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,mBAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,YAAY;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gCAAgC,aAAa;AAC1D,IAAI,mBAAmB;AACvB;AACO,mCAAmC,aAAa;AACvD;AACA;AACA;AACA,IAAI,yBAAyB,YAAY,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,IAAI,aAAa;AACjB;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;AACA,iCAAiC,mBAAmB;AACpD,iCAAiC,OAAO;AACxC,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA;;AC3Fa;AACb;AAKmC;AACnC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,IAAI;AACJ,4CAA4C,kBAAkB;AAC9D,4CAA4C,oBAAoB;AAChE,4CAA4C,oBAAoB;AAChE;AACA;AACA,sB","sources":["webpack://js-inheritance-imitator/./src/Identifier.js","webpack://js-inheritance-imitator/./src/Logger.js","webpack://js-inheritance-imitator/./src/SuperExtensionManager.js","webpack://js-inheritance-imitator/./src/AccessorDescriptorReplicator.js","webpack://js-inheritance-imitator/./src/DataDescriptorReplicator.js","webpack://js-inheritance-imitator/./src/Cloner.js","webpack://js-inheritance-imitator/./test/Student.js","webpack://js-inheritance-imitator/./test/Informatician.js","webpack://js-inheritance-imitator/./src/Extension.js","webpack://js-inheritance-imitator/./test/WorkingProfessional.js","webpack://js-inheritance-imitator/./test/InformaticsStudent.js","webpack://js-inheritance-imitator/./index.js"],"sourcesContent":["export default class Identifier {\r\n\r\n  static instanceof( hostObject, constructorObject, testNative = true ) {\r\n    if ( !Identifier.isObject( hostObject ) ) return false;\r\n    const isConstructorFunction = Identifier\r\n      .isConstructorFunction( constructorObject );\r\n    if ( isConstructorFunction &&\r\n      hostObject.constructor === constructorObject ) return true;\r\n    if ( testNative && isConstructorFunction &&\r\n      hostObject instanceof constructorObject )\r\n      return true;\r\n    if ( !Identifier.isSet( hostObject.__extends ) ) return false;\r\n    if ( hostObject.__extends.has( constructorObject ) ) return true;\r\n    return isConstructorFunction && [ ...hostObject.__extends.values() ]\r\n      .some( extension => {\r\n        if ( extension.constructor == constructorObject ) return true;\r\n        const constructorFunction =\r\n          Identifier.isConstructorFunction( extension.constructor ) ?\r\n          extension.constructor :\r\n          Identifier.isConstructorFunction( extension ) ? extension : void 0;\r\n        if ( !constructorFunction ) return false;\r\n        let testInstance = void 0;\r\n        try {\r\n          testInstance = new constructorFunction();\r\n        } catch ( err ) {}\r\n        if ( !testInstance ) return false;\r\n        if ( testNative && testInstance instanceof constructorObject )\r\n          return true;\r\n        if ( !Identifier.isFunction( testInstance.instanceof ) ) return false;\r\n        return !!testInstance.instanceof( constructorObject );\r\n      } );\r\n  }\r\n\r\n  static isProtoype( inputParameter ) {\r\n    return Identifier.isObject( inputParameter ) &&\r\n      Reflect.has( inputParameter, \"constructor\" );\r\n  }\r\n\r\n  static isConstructorFunction( inputParameter ) {\r\n    return typeof inputParameter == \"function\" &&\r\n      Reflect.has( inputParameter, \"prototype\" ) &&\r\n      Reflect.has( inputParameter, \"constructor\" );\r\n  }\r\n\r\n  static isObject( inputParameter ) {\r\n    return !!inputParameter && typeof inputParameter == \"object\";\r\n  }\r\n\r\n  static isString( inputParameter ) {\r\n    return !!inputParameter &&\r\n      typeof inputParameter == \"string\" && inputParameter.length > 0;\r\n  }\r\n\r\n  static isNumber( inputParameter ) {\r\n    return typeof inputParameter == \"number\";\r\n  }\r\n\r\n  static isInteger( inputParameter ) {\r\n    return Identifier.isNumber( inputParameter ) &&\r\n      Number.isInteger( inputParameter );\r\n  }\r\n\r\n  static isPositiveNumber( inputParameter, canBeZero = true ) {\r\n    return Identifier.isNumber( inputParameter ) &&\r\n      ( !canBeZero ? inputParameter > 0 : inputParameter >= 0 );\r\n  }\r\n\r\n  static isPositiveInteger( inputParameter, canBeZero = true ) {\r\n    return Identifier.isInteger( inputParameter ) &&\r\n      Identifier.isPositiveNumber( inputParameter, canBeZero );\r\n  }\r\n\r\n  static isBoolean( inputParameter ) {\r\n    return typeof inputParameter == \"boolean\";\r\n  }\r\n\r\n  static isFunction( inputParameter ) {\r\n    return !!inputParameter && typeof inputParameter == \"function\";\r\n  }\r\n\r\n  static isArray( inputParameter, testLength = false ) {\r\n    if ( !( inputParameter instanceof Array ) ) return false;\r\n    if ( Identifier.isBoolean( testLength ) )\r\n      return !testLength ? true : inputParameter.length > 0;\r\n    if ( !Identifier.isPositiveInteger( testLength, true ) ) return true;\r\n    return inputParameter.length === testLength;\r\n  }\r\n\r\n  static isSet( inputParameter, testSize = false ) {\r\n    return !( inputParameter instanceof Set ) ? false : !testSize ? true :\r\n      inputParameter.size > 0;\r\n  }\r\n\r\n  static isIterable( inputParameter ) {\r\n    if ( !Identifier.isObject( inputParameter ) &&\r\n      !Identifier.isString( inputParameter ) ) return false;\r\n    return Identifier.isFunction( inputParameter[ Symbol.iterator ] );\r\n  }\r\n\r\n  static isObjectPath( parentObject, pathString = \"\" ) {\r\n    if ( !Identifier.isFunction( pathString.split ) ) return false;\r\n    let pathArray = pathString.split( \".\" );\r\n    if ( pathArray.length > 0 ) pathArray.shift();\r\n    return Identifier._isObjectHierarchy( parentObject, pathArray );\r\n  }\r\n\r\n  static isFunctionPath( parentObject, pathString = \"\" ) {\r\n    if ( !Identifier.isString( pathString ) )\r\n      return Identifier.isFunction( pathString ) ||\r\n        Identifier.isFunction( parentObject );\r\n    if ( pathString.indexOf( \".\" ) < 0 )\r\n      return Identifier.isObject( parentObject ) &&\r\n        Identifier.isFunction( parentObject[ pathString ] );\r\n    let pathArray = pathString.split( \".\" );\r\n    if ( pathArray.length < 1 ) return Identifier.isFunction( parentObject );\r\n    if ( pathArray.length == 1 ) return Identifier.isFunction( parentObject ) ||\r\n      Identifier.isObject( parentObject ) &&\r\n      Identifier.isFunction( parentObject[ pathString ] );\r\n    pathArray.shift();\r\n    const functionName = pathArray[ pathArray.length - 1 ];\r\n    pathArray.splice( -1 );\r\n    if ( !Identifier._isObjectHierarchy( parentObject, pathArray ) ) return false;\r\n    const finalObject = Identifier._getObjectFromHierarchy( parentObject, pathArray );\r\n    return Identifier.isObject( finalObject ) &&\r\n      Identifier.isFunction( finalObject[ functionName ] );\r\n  }\r\n\r\n  static _isObjectHierarchy( parentObject, levelsArray = [] ) {\r\n    if ( !Identifier.isObject( parentObject ) ) return false;\r\n    let currentlyValidating = parentObject;\r\n    for ( let childLevelName of levelsArray ) {\r\n      currentlyValidating = currentlyValidating[ childLevelName ];\r\n      if ( !Identifier.isObject( currentlyValidating ) ) return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  static _getObjectFromHierarchy( parentObject, pathArray = [], validateEachLevel = false ) {\r\n    if ( !Identifier.isObject( parentObject ) ) return void 0;\r\n    let finalObject = parentObject;\r\n    for ( let childLevelName of pathArray ) {\r\n      finalObject = finalObject[ childLevelName ];\r\n      if ( !!validateEachLevel && !Identifier.isObject( finalObject ) )\r\n        return void 0;\r\n    }\r\n    return finalObject;\r\n  }\r\n\r\n  static generateRandomString( prefix = \"\", suffix = \"\", length = void 0 ) {\r\n    let now = Date.now();\r\n    let randomString = ( now * Math.random() ).toString( 36 ).replace( /\\./g, now );\r\n    if ( Identifier.isPositiveInteger( length ) )\r\n      randomString = randomString.length >= length ?\r\n      randomString.substring( 0, length - 1 ) :\r\n      randomString + Math.pow( 10, length - randomString.length - 1 );\r\n    if ( Identifier.isString( prefix ) ) randomString = prefix + randomString;\r\n    if ( Identifier.isString( suffix ) ) randomString = randomString + suffix;\r\n    return randomString;\r\n  }\r\n\r\n  static _getFirstMatchArr( source, regExp ) {\r\n    if ( !Identifier.isString( source ) ) return void 0;\r\n    if ( Identifier.isString( regExp ) ) regExp = new RegExp( regExp, \"g\" );\r\n    if ( !( regExp instanceof RegExp ) ) return void 0;\r\n    const matches = [ ...source.matchAll( regExp ) ];\r\n    if ( !Identifier.isArray( matches, true ) ) return void 0;\r\n    const firstMatch = matches[ 0 ];\r\n    if ( !Identifier.isArray( firstMatch, true ) ) return void 0;\r\n    return firstMatch;\r\n  }\r\n\r\n  static firstMatchIndex( source, regExp ) {\r\n    const firstMatch = Identifier._getFirstMatchArr( source, regExp );\r\n    if ( !Identifier.isArray( firstMatch, true ) ) return -1;\r\n    const index = firstMatch.index;\r\n    return Identifier.isPositiveInteger( index ) ? index : -1;\r\n  }\r\n\r\n}","import Identifier from './Identifier';\r\n\r\nexport default class Logger {\r\n\r\n  static _trace( logMessage, errorOrErrorText = null, returnValue ) {\r\n    if ( !Identifier.isString( logMessage ) ) logMessage = \"\";\r\n    console.group( \"[ \" + Logger.getCurrentTime() + \" ] \" + logMessage );\r\n    if ( Identifier.isString( errorOrErrorText ) ||\r\n      Identifier.isObject( errorOrErrorText ) ) {\r\n      console.groupCollapsed( \"%cError\", \"color: #009688\" );\r\n      console.warn( errorOrErrorText );\r\n      console.groupEnd();\r\n    }\r\n    console.groupCollapsed( \"%c Call Stack\", \"color: #009688\" );\r\n    console.trace( \"%c \", \"color: #009688\" );\r\n    console.groupEnd();\r\n    console.groupEnd();\r\n    return returnValue;\r\n  }\r\n\r\n  static trace( logMessage, errorOrErrorText = null, returnValue ) {\r\n    let fullFunctionName = Logger.getFullFunctionName( 1, \".\" );\r\n    let message = \"\";\r\n    if ( Identifier.isString( fullFunctionName ) ) message += fullFunctionName;\r\n    if ( Identifier.isString( logMessage ) )\r\n      message += !Identifier.isString( message ) ? logMessage : \"\\n\" + logMessage;\r\n    return Logger._trace( message, errorOrErrorText, returnValue );\r\n  }\r\n\r\n  static traceIf( doTrace = true, logMessage, errorOrErrorText = null, returnValue ) {\r\n    if ( !doTrace ) return returnValue;\r\n    return Logger.trace( logMessage, errorOrErrorText, returnValue );\r\n  }\r\n\r\n  static getCurrentTime() {\r\n    let fullDate = new Date();\r\n    let hours = Logger.dateNumberToString( fullDate.getHours() );\r\n    let minutes = Logger.dateNumberToString( fullDate.getMinutes() );\r\n    let seconds = Logger.dateNumberToString( fullDate.getSeconds() );\r\n    let milliseconds = Logger.dateNumberToString( fullDate.getMilliseconds(), true );\r\n    return `${ hours }:${ minutes }:${ seconds }:${ milliseconds }`;\r\n  }\r\n\r\n  static dateNumberToString( dateNumber, threeDigits = false ) {\r\n    if ( !Identifier.isPositiveInteger( dateNumber ) ) return \"\";\r\n    let stringDateNumber = dateNumber.toString();\r\n    while ( stringDateNumber.length < 2 )\r\n      stringDateNumber = \"0\" + stringDateNumber;\r\n    while ( threeDigits && stringDateNumber.length < 3 )\r\n      stringDateNumber = \"0\" + stringDateNumber;\r\n    return stringDateNumber;\r\n  }\r\n\r\n  static getFullFunctionName( topEntriesToRemove = 0, separator = \"#\" ) {\r\n    topEntriesToRemove = Identifier.isInteger( topEntriesToRemove ) ?\r\n      topEntriesToRemove + 2 : 2;\r\n    let stack = Logger.getStack( topEntriesToRemove );\r\n    if ( !Identifier.isString( stack ) ) return void 0;\r\n    if ( stack.startsWith( \"at \" ) ) {\r\n      stack = stack.substring( 3 );\r\n    }\r\n    const spaceIndex = stack.indexOf( \" \" );\r\n    if ( !Identifier.isInteger( spaceIndex ) || spaceIndex < 0 ||\r\n      stack.length - 1 < spaceIndex + 1 ) return stack;\r\n    stack = stack.substring( 0, spaceIndex );\r\n    const atIndex = stack.indexOf( \"@\" );\r\n    if ( Identifier.isInteger( atIndex ) && atIndex >= 0 &&\r\n      stack.length - 1 >= atIndex + 1 ) stack = stack.substring( 0, atIndex );\r\n    if ( Identifier.isString( separator ) ) {\r\n      stack = stack.replace( \".\", separator );\r\n    }\r\n    return stack;\r\n  }\r\n\r\n  static getStack( topEntriesToRemove = 1 ) {\r\n    const err = new Error();\r\n    if ( !Identifier.isObject( err ) ) return void 0;\r\n    let stack = err.stack;\r\n    if ( !Identifier.isString( stack ) ) return void 0;\r\n    if ( !Identifier.isInteger( topEntriesToRemove ) )\r\n      topEntriesToRemove = 1;\r\n    if ( Identifier.firstMatchIndex( stack, /\\sat\\s/g ) < 0 ) topEntriesToRemove--;\r\n    while ( topEntriesToRemove > -1 ) {\r\n      const firstNewLineIndex = stack.indexOf( \"\\n\" );\r\n      if ( !Identifier.isInteger( firstNewLineIndex ) || firstNewLineIndex < 0 ||\r\n        stack.length - 1 < firstNewLineIndex + 1 ) break;\r\n      stack = stack.substring( firstNewLineIndex + 1 );\r\n      topEntriesToRemove--;\r\n    }\r\n    while ( stack.length > 0 && !!stack.charAt( 0 ).match( /\\s/gi ) )\r\n      stack = stack.substring( 1 );\r\n    return stack;\r\n  }\r\n}","import Identifier from './Identifier';\r\nimport Logger from './Logger';\r\n\r\nexport default class SuperExtensionManager {\r\n\r\n  static addSuperMethod( hostObject ) {\r\n    if ( !Identifier.isObject( hostObject ) ||\r\n      Identifier.isFunction( hostObject.super ) ) return false;\r\n    hostObject.super = ( methodName, ...args ) => {\r\n      if ( !Identifier.isSet( hostObject.__extends ) ) return void 0;\r\n      let superPrototype = void 0;\r\n      for ( let extensionObject of hostObject.__extends ) {\r\n        let currentPrototype = Identifier\r\n          .isConstructorFunction( extensionObject ) ? extensionObject.prototype :\r\n          Identifier.isProtoype( extensionObject ) ? extensionObject : void 0;\r\n        if ( !currentPrototype ||\r\n          !Identifier.isFunction( currentPrototype[ methodName ] ) ) continue;\r\n        if ( hostObject[ methodName ] == currentPrototype[ methodName ] ) {\r\n          continue;\r\n        }\r\n        superPrototype = currentPrototype;\r\n        break;\r\n      }\r\n      if ( !superPrototype ) return void 0;\r\n      const temporaryMethodName = Identifier\r\n        .generateRandomString( \"__tempSuperMethod\" ).replaceAll( /\\W/g, \"\" );\r\n      hostObject[ temporaryMethodName ] = superPrototype[ methodName ];\r\n      const returnValue = hostObject[ temporaryMethodName ]( ...args );\r\n      delete hostObject[ temporaryMethodName ];\r\n      return returnValue;\r\n    };\r\n    return true;\r\n  }\r\n\r\n  static addSuperFromMethod( hostObject ) {\r\n    if ( !Identifier.isObject( hostObject ) ||\r\n      Identifier.isFunction( hostObject.superFrom ) ) return false;\r\n    hostObject.superFrom = ( constructorObject, methodName, ...args ) => {\r\n      if ( !Identifier.isConstructorFunction( constructorObject ) ||\r\n        !Identifier.isSet( hostObject.__extends ) ||\r\n        !hostObject.__extends.has( constructorObject ) ||\r\n        !Identifier.isFunction( constructorObject.prototype[ methodName ] ) )\r\n        return void 0;\r\n      if ( hostObject[ methodName ] == constructorObject.prototype[ methodName ] )\r\n        return void 0;\r\n      const temporaryMethodName = Identifier\r\n        .generateRandomString( \"__tempSuperMethod\" ).replaceAll( /\\W/g, \"\" );\r\n      hostObject[ temporaryMethodName ] = constructorObject.prototype[ methodName ];\r\n      const returnValue = hostObject[ temporaryMethodName ]( ...args );\r\n      delete hostObject[ temporaryMethodName ];\r\n      return returnValue;\r\n    };\r\n    return true;\r\n  }\r\n\r\n  static registerInstance( hostObject, constructorObject ) {\r\n    if ( !Identifier.isObject( hostObject ) ) return false;\r\n    if ( !Identifier.isObject( constructorObject ) &&\r\n      !Identifier.isFunction( constructorObject ) ) return false;\r\n    SuperExtensionManager.addInstanceofFunction( hostObject );\r\n    SuperExtensionManager.addExtendsSet( hostObject );\r\n    SuperExtensionManager.redefineHasInstanceSymbol( constructorObject );\r\n    hostObject.__extends.add( constructorObject );\r\n    hostObject.__extends = new Set( [ ...hostObject.__extends,\r\n      ...SuperExtensionManager.getPrototypeExtensions( constructorObject )\r\n    ] );\r\n    return true;\r\n  }\r\n\r\n  static getPrototypeExtensions( constructorObject ) {\r\n    const prototype = Identifier.isConstructorFunction( constructorObject ) ?\r\n      constructorObject.prototype : Identifier.isProtoype( constructorObject ) ?\r\n      constructorObject : void 0;\r\n    if ( !prototype ) return new Set();\r\n    return Identifier.isSet( prototype.__extends ) ? prototype.__extends :\r\n      new Set();\r\n  }\r\n\r\n  static addExtendsSet( hostObject ) {\r\n    if ( !Identifier.isObject( hostObject ) ||\r\n      Identifier.isSet( hostObject.__extends ) ) return false;\r\n    hostObject.__extends = new Set();\r\n    return true;\r\n  }\r\n\r\n  static addInstanceofFunction( hostObject ) {\r\n    if ( !Identifier.isObject( hostObject ) ||\r\n      Identifier.isFunction( hostObject.instanceof ) ) return false;\r\n    hostObject.instanceof = ( constructorObject ) => {\r\n      return Identifier.instanceof( hostObject, constructorObject );\r\n    }\r\n    return true;\r\n  }\r\n\r\n  static redefineHasInstanceSymbol( constructorObject ) {\r\n    const constructorFunction =\r\n      Identifier.isConstructorFunction( constructorObject ) ?\r\n      constructorObject : Identifier.isProtoype( constructorObject ) ?\r\n      constructorObject.constructor : void 0;\r\n    if ( !constructorFunction ) return false;\r\n    if ( SuperExtensionManager\r\n      .ownsHasInstanceSymbolProperty( constructorFunction ) ) return true;\r\n    let success = false;\r\n    try {\r\n      const nativeFunction = constructorFunction[ Symbol.hasInstance ];\r\n      Object.defineProperty( constructorFunction, Symbol.hasInstance, {\r\n        value: function( leftHandOperand ) {\r\n          if ( Identifier.isFunction( nativeFunction ) &&\r\n            nativeFunction( leftHandOperand ) ) return true;\r\n          return Identifier\r\n            .instanceof( leftHandOperand, constructorFunction, false );\r\n        }\r\n      } );\r\n      success = true;\r\n    } catch ( err ) {}\r\n    return success;\r\n  }\r\n\r\n  static ownsHasInstanceSymbolProperty( constructorFunction ) {\r\n    if ( !Identifier.isConstructorFunction( constructorFunction ) ) return false;\r\n    const propertySymbols = Object.getOwnPropertySymbols( constructorFunction );\r\n    if ( !Identifier.isArray( propertySymbols ) ) return false;\r\n    return propertySymbols.some( propertySymbol =>\r\n      propertySymbol.toString() == \"Symbol(Symbol.hasInstance)\" );\r\n  }\r\n\r\n}","import Cloner from './Cloner';\r\nimport Identifier from './Identifier';\r\nimport Logger from './Logger';\r\n\r\nexport default class AccessorDescriptorReplicator {\r\n\r\n  static mirrorGettersAndSettersFromInstanceOnWholePrototypeChain( {\r\n    hostObject,\r\n    instance,\r\n    override = false\r\n  } ) {\r\n    if ( !Identifier.isObject( instance ) ) return false;\r\n    return AccessorDescriptorReplicator\r\n      .mirrorGettersAndSettersFromPrototypeOnWholePrototypeChain( {\r\n        hostObject: hostObject,\r\n        prototype: Object.getPrototypeOf( instance ),\r\n        override: override\r\n      } );\r\n  }\r\n\r\n  static mirrorGettersAndSettersFromPrototypeOnWholePrototypeChain( {\r\n    hostObject,\r\n    prototype,\r\n    override = false\r\n  } ) {\r\n    let currentSource = prototype;\r\n    if ( !AccessorDescriptorReplicator.mirrorGettersAndSettersFromPrototype( {\r\n        hostObject: hostObject,\r\n        prototype: currentSource,\r\n        override: override\r\n      } ) ) return false;\r\n    let lastReplicationSuccessfull = true;\r\n    while ( lastReplicationSuccessfull ) {\r\n      currentSource = Object.getPrototypeOf( currentSource );\r\n      if ( !Identifier.isObject( currentSource ) ) break;\r\n      const constructorName = currentSource.constructor.name;\r\n      if ( !Identifier.isString( constructorName ) || [\r\n          \"Object\", \"Function\"\r\n        ].indexOf( constructorName ) >= 0 ) break;\r\n      lastReplicationSuccessfull = AccessorDescriptorReplicator\r\n        .mirrorGettersAndSettersFromPrototype( {\r\n          hostObject: hostObject,\r\n          prototype: currentSource,\r\n          override: false\r\n        } );\r\n    }\r\n    return lastReplicationSuccessfull;\r\n  }\r\n\r\n  static mirrorGettersAndSettersFromInstance( {\r\n    hostObject,\r\n    instance,\r\n    override = false\r\n  } ) {\r\n    if ( !Identifier.isObject( instance ) ) return false;\r\n    return AccessorDescriptorReplicator.mirrorGettersAndSettersFromPrototype( {\r\n      hostObject: hostObject,\r\n      prototype: Object.getPrototypeOf( instance ),\r\n      override: override\r\n    } );\r\n  }\r\n\r\n  static mirrorGettersAndSettersFromPrototype( {\r\n    hostObject,\r\n    prototype,\r\n    override = false\r\n  } ) {\r\n    if ( !Identifier.isObject( hostObject ) ) return false;\r\n    if ( !Object.isExtensible( hostObject ) )\r\n      return Logger.trace( `Could not assign/copy/mirror getter and setter` +\r\n        ` (accessor descriptor) properties to a non extensible object.`, null, false );\r\n    const getterSetterPropertyNames = AccessorDescriptorReplicator\r\n      .getAccessorDescriptorPropertyNamesFromPrototype( prototype );\r\n    if ( !Identifier.isIterable( getterSetterPropertyNames ) ) return false;\r\n    let mirroredPropertiesCounter = 0;\r\n    for ( let propertyName of getterSetterPropertyNames ) {\r\n      if ( !AccessorDescriptorReplicator.mirrorGetterSetterFromPrototype( {\r\n          hostObject: hostObject,\r\n          prototype: prototype,\r\n          propertyName: propertyName,\r\n          override: override\r\n        } ) ) continue;\r\n      mirroredPropertiesCounter++;\r\n    }\r\n    return mirroredPropertiesCounter == getterSetterPropertyNames.length;\r\n  }\r\n\r\n  static mirrorGetterSetterFromInstance( {\r\n    hostObject,\r\n    instance,\r\n    propertyName,\r\n    override = false\r\n  } ) {\r\n    if ( !Identifier.isObject( instance ) ) return false;\r\n    return AccessorDescriptorReplicator.mirrorGetterSetterFromPrototype( {\r\n      hostObject: hostObject,\r\n      prototype: Object.getPrototypeOf( instance ),\r\n      propertyName: propertyName,\r\n      override: override\r\n    } );\r\n  }\r\n\r\n  static mirrorGetterSetterFromPrototype( {\r\n    hostObject,\r\n    prototype,\r\n    propertyName,\r\n    override = false\r\n  } ) {\r\n    const propertyDescriptor = Cloner.getClonablePropertyDescriptor( {\r\n      hostObject: hostObject,\r\n      prototype: prototype,\r\n      propertyName: propertyName,\r\n      override: !!override\r\n    } );\r\n    if ( !Identifier.isObject( propertyDescriptor ) ) return false;\r\n    Object.defineProperty( hostObject, propertyName, {\r\n      get: propertyDescriptor.get,\r\n      set: propertyDescriptor.set,\r\n      configurable: !!propertyDescriptor.configurable,\r\n      enumerable: !!propertyDescriptor.enumerable\r\n    } );\r\n    return true;\r\n  }\r\n\r\n  static getAccessorDescriptorPropertyNamesFromInstance( instance ) {\r\n    if ( !Identifier.isObject( instance ) ) return void 0;\r\n    const instancePrototype = Object.getPrototypeOf( instance );\r\n    return AccessorDescriptorReplicator\r\n      .getAccessorDescriptorPropertyNamesFromPrototype( instancePrototype );\r\n  }\r\n\r\n  static getAccessorDescriptorPropertyNamesFromPrototype( prototype ) {\r\n    if ( !Identifier.isObject( prototype ) )\r\n      return Logger.trace( `Could not identify and filter getter and setter` +\r\n        ` properties from an invalid prototype.`, null, void 0 );\r\n    const getterSetterPropertyNames = Object.getOwnPropertyNames( prototype )\r\n      .filter( propertyName => {\r\n        return AccessorDescriptorReplicator\r\n          .isSetterGetterPropertyName( prototype, propertyName );\r\n      } );\r\n    return getterSetterPropertyNames;\r\n  }\r\n\r\n  static isSetterGetterPropertyName( prototype, propertyName ) {\r\n    if ( !Identifier.isObject( prototype ) ||\r\n      !Identifier.isString( propertyName ) || !( propertyName in prototype ) )\r\n      return false;\r\n    const propertyDescriptor =\r\n      Object.getOwnPropertyDescriptor( prototype, propertyName );\r\n    return AccessorDescriptorReplicator.hasSetterOrGetter( propertyDescriptor );\r\n  }\r\n\r\n  static isAccessorDescriptor( propertyDescriptor ) {\r\n    return AccessorDescriptorReplicator.hasSetterOrGetter( propertyDescriptor );\r\n  }\r\n\r\n  static hasSetterOrGetter( propertyDescriptor ) {\r\n    if ( !Identifier.isObject( propertyDescriptor ) ) return false;\r\n    return [ \"get\", \"set\" ].some( descriptorPart =>\r\n      Identifier.isFunction( propertyDescriptor[ descriptorPart ] ) );\r\n  }\r\n\r\n}","import Cloner from './Cloner';\r\nimport Identifier from './Identifier';\r\nimport Logger from './Logger';\r\n\r\nconst NON_CLONABLE_PROPERTY_NAMES = [ \"constructor\", \"super\",\r\n  \"instanceof\", \"__extends\"\r\n];\r\n\r\nexport default class DataDescriptorReplicator {\r\n\r\n  static mirrorDataDescriptorsFromInstanceOnWholePrototypeChain( {\r\n    hostObject,\r\n    instance,\r\n    mirrorFunctions = true,\r\n    mirrorOthers = true,\r\n    overrideFunctions = false,\r\n    overrideOthers = false\r\n  } ) {\r\n    if ( !Identifier.isObject( instance ) ) return false;\r\n    return DataDescriptorReplicator\r\n      .mirrorDataDescriptorsFromPrototypeOnWholePrototypeChain( {\r\n        hostObject: hostObject,\r\n        prototype: Object.getPrototypeOf( instance ),\r\n        mirrorFunctions: mirrorFunctions,\r\n        mirrorOthers: mirrorOthers,\r\n        overrideFunctions: overrideFunctions,\r\n        overrideOthers: overrideOthers\r\n      } );\r\n  }\r\n\r\n  static mirrorDataDescriptorsFromPrototypeOnWholePrototypeChain( {\r\n    hostObject,\r\n    prototype,\r\n    mirrorFunctions = true,\r\n    mirrorOthers = true,\r\n    overrideFunctions = false,\r\n    overrideOthers = false\r\n  } ) {\r\n    let currentSource = prototype;\r\n    if ( !DataDescriptorReplicator.mirrorDataDescriptorsFromPrototype( {\r\n        hostObject: hostObject,\r\n        prototype: currentSource,\r\n        mirrorFunctions: mirrorFunctions,\r\n        mirrorOthers: mirrorOthers,\r\n        overrideFunctions: overrideFunctions,\r\n        overrideOthers: overrideOthers\r\n      } ) ) return false;\r\n    let lastReplicationSuccessfull = true;\r\n    while ( lastReplicationSuccessfull ) {\r\n      currentSource = Object.getPrototypeOf( currentSource );\r\n      if ( !Identifier.isObject( currentSource ) ) break;\r\n      const constructorName = currentSource.constructor.name;\r\n      if ( !Identifier.isString( constructorName ) || [\r\n          \"Object\", \"Function\"\r\n        ].indexOf( constructorName ) >= 0 ) break;\r\n      lastReplicationSuccessfull = DataDescriptorReplicator\r\n        .mirrorDataDescriptorsFromPrototype( {\r\n          hostObject: hostObject,\r\n          prototype: currentSource,\r\n          mirrorFunctions: mirrorFunctions,\r\n          mirrorOthers: mirrorOthers,\r\n          overrideFunctions: overrideFunctions,\r\n          overrideOthers: overrideOthers\r\n        } );\r\n    }\r\n    return lastReplicationSuccessfull;\r\n  }\r\n\r\n  static mirrorDataDescriptorsFromInstance( {\r\n    hostObject,\r\n    instance,\r\n    mirrorFunctions = true,\r\n    mirrorOthers = true,\r\n    overrideFunctions = false,\r\n    overrideOthers = false\r\n  } ) {\r\n    if ( !Identifier.isObject( instance ) ) return false;\r\n    return DataDescriptorReplicator.mirrorGettersAndSettersFromPrototype( {\r\n      hostObject: hostObject,\r\n      prototype: Object.getPrototypeOf( instance ),\r\n      mirrorFunctions: mirrorFunctions,\r\n      mirrorOthers: mirrorOthers,\r\n      overrideFunctions: overrideFunctions,\r\n      overrideOthers: overrideOthers\r\n    } );\r\n  }\r\n\r\n  static mirrorDataDescriptorsFromPrototype( {\r\n    hostObject,\r\n    prototype,\r\n    mirrorFunctions = true,\r\n    mirrorOthers = true,\r\n    overrideFunctions = false,\r\n    overrideOthers = false\r\n  } ) {\r\n    if ( !mirrorFunctions && !mirrorOthers ) return false;\r\n    if ( !Identifier.isObject( hostObject ) ) return false;\r\n    if ( !Object.isExtensible( hostObject ) )\r\n      return Logger.trace( `Could not assign/copy/mirror getter and setter` +\r\n        ` (accessor descriptor) properties to a non extensible object.`, null, false );\r\n    if ( mirrorFunctions ) {\r\n      const functionPropertyNames = DataDescriptorReplicator\r\n        .getFunctionPropertyNamesFromPrototype( prototype );\r\n      if ( Identifier.isIterable( functionPropertyNames ) )\r\n        for ( let propertyName of functionPropertyNames ) {\r\n          DataDescriptorReplicator.mirrorDataDescriptorFromPrototype( {\r\n            hostObject: hostObject,\r\n            prototype: prototype,\r\n            propertyName: propertyName,\r\n            override: overrideFunctions\r\n          } );\r\n        }\r\n    }\r\n    if ( !mirrorOthers ) return true;\r\n    const dataValuePropertyNames = DataDescriptorReplicator\r\n      .getDataValuePropertyNamesFromPrototype( prototype );\r\n    if ( !Identifier.isIterable( dataValuePropertyNames ) ) return true;\r\n    for ( let propertyName of dataValuePropertyNames ) {\r\n      DataDescriptorReplicator.mirrorDataDescriptorFromPrototype( {\r\n        hostObject: hostObject,\r\n        prototype: prototype,\r\n        propertyName: propertyName,\r\n        override: overrideOthers\r\n      } );\r\n    }\r\n    return true;\r\n  }\r\n\r\n  static mirrorDataDescriptorFromPrototype( {\r\n    hostObject,\r\n    prototype,\r\n    propertyName,\r\n    override = false\r\n  } ) {\r\n    const propertyDescriptor = Cloner.getClonablePropertyDescriptor( {\r\n      hostObject: hostObject,\r\n      prototype: prototype,\r\n      propertyName: propertyName,\r\n      override: !!override\r\n    } );\r\n    if ( !Identifier.isObject( propertyDescriptor ) ) return false;\r\n    Object.defineProperty( hostObject, propertyName, {\r\n      value: propertyDescriptor.value,\r\n      writable: propertyDescriptor.writable,\r\n      configurable: !!propertyDescriptor.configurable,\r\n      enumerable: !!propertyDescriptor.enumerable\r\n    } );\r\n    return true;\r\n  }\r\n\r\n  static getDataDescriptorPropertyNamesFromInstance( instance ) {\r\n    if ( !Identifier.isObject( instance ) ) return void 0;\r\n    const instancePrototype = Object.getPrototypeOf( instance );\r\n    return DataDescriptorReplicator\r\n      .getDataDescriptorPropertyNamesFromPrototype( instancePrototype );\r\n  }\r\n\r\n  static getFunctionPropertyNamesFromInstance( instance ) {\r\n    if ( !Identifier.isObject( instance ) ) return void 0;\r\n    const instancePrototype = Object.getPrototypeOf( instance );\r\n    return DataDescriptorReplicator\r\n      .getFunctionPropertyNamesFromPrototype( instancePrototype );\r\n  }\r\n\r\n  static getDataValuePropertyNamesFromInstance( instance ) {\r\n    if ( !Identifier.isObject( instance ) ) return void 0;\r\n    const instancePrototype = Object.getPrototypeOf( instance );\r\n    return DataDescriptorReplicator\r\n      .getDataValuePropertyNamesFromPrototype( instancePrototype );\r\n  }\r\n\r\n  static getDataDescriptorPropertyNamesFromPrototype( prototype ) {\r\n    if ( !Identifier.isObject( prototype ) )\r\n      return Logger.trace( `Could not identify and filter data descriptor` +\r\n        ` properties from an invalid prototype.`, null, void 0 );\r\n    const dataDescriptorPropertyNames = Object.getOwnPropertyNames( prototype )\r\n      .filter( propertyName => {\r\n        return DataDescriptorReplicator\r\n          .isDataDescriptorPropertyName( prototype, propertyName );\r\n      } );\r\n    return dataDescriptorPropertyNames;\r\n  }\r\n\r\n  static getFunctionPropertyNamesFromPrototype( prototype ) {\r\n    if ( !Identifier.isObject( prototype ) )\r\n      return Logger.trace( `Could not identify and filter function` +\r\n        ` properties from an invalid prototype.`, null, void 0 );\r\n    const functionPropertyNames = Object.getOwnPropertyNames( prototype )\r\n      .filter( propertyName => {\r\n        return DataDescriptorReplicator\r\n          .isFunctionPropertyName( prototype, propertyName );\r\n      } );\r\n    return functionPropertyNames;\r\n  }\r\n\r\n  static getDataValuePropertyNamesFromPrototype( prototype ) {\r\n    if ( !Identifier.isObject( prototype ) )\r\n      return Logger.trace( `Could not identify and filter data value` +\r\n        ` properties from an invalid prototype.`, null, void 0 );\r\n    const dataValuePropertyNames = Object.getOwnPropertyNames( prototype )\r\n      .filter( propertyName => {\r\n        return DataDescriptorReplicator\r\n          .isDataValuePropertyName( prototype, propertyName );\r\n      } );\r\n    return dataValuePropertyNames;\r\n  }\r\n\r\n  static isDataDescriptorPropertyName( prototype, propertyName ) {\r\n    if ( !Identifier.isObject( prototype ) ||\r\n      !Identifier.isString( propertyName ) || !( propertyName in prototype ) ||\r\n      NON_CLONABLE_PROPERTY_NAMES.indexOf( propertyName ) >= 0 )\r\n      return false;\r\n    const propertyDescriptor =\r\n      Object.getOwnPropertyDescriptor( prototype, propertyName );\r\n    return DataDescriptorReplicator.isDataDescriptor( propertyDescriptor );\r\n  }\r\n\r\n  static isFunctionPropertyName( prototype, propertyName ) {\r\n    if ( !Identifier.isObject( prototype ) ||\r\n      !Identifier.isString( propertyName ) || !( propertyName in prototype ) ||\r\n      NON_CLONABLE_PROPERTY_NAMES.indexOf( propertyName ) >= 0 )\r\n      return false;\r\n    const propertyDescriptor =\r\n      Object.getOwnPropertyDescriptor( prototype, propertyName );\r\n    return DataDescriptorReplicator\r\n      .isFunctionPropertyDescriptor( propertyDescriptor );\r\n  }\r\n\r\n  static isDataValuePropertyName( prototype, propertyName ) {\r\n    if ( !Identifier.isObject( prototype ) ||\r\n      !Identifier.isString( propertyName ) || !( propertyName in prototype ) ||\r\n      NON_CLONABLE_PROPERTY_NAMES.indexOf( propertyName ) >= 0 )\r\n      return false;\r\n    const propertyDescriptor =\r\n      Object.getOwnPropertyDescriptor( prototype, propertyName );\r\n    return DataDescriptorReplicator\r\n      .isDataValuePropertyDescriptor( propertyDescriptor );\r\n  }\r\n\r\n  static isDataDescriptor( propertyDescriptor ) {\r\n    if ( !Identifier.isObject( propertyDescriptor ) ) return false;\r\n    return Reflect.has( propertyDescriptor, \"value\" );\r\n  }\r\n\r\n  static isFunctionPropertyDescriptor( propertyDescriptor ) {\r\n    if ( !Identifier.isObject( propertyDescriptor ) ) return false;\r\n    return Identifier.isFunction( propertyDescriptor.value );\r\n  }\r\n\r\n  static isDataValuePropertyDescriptor( propertyDescriptor ) {\r\n    if ( !Identifier.isObject( propertyDescriptor ) ) return false;\r\n    return Reflect.has( propertyDescriptor, \"value\" ) &&\r\n      !Identifier.isFunction( propertyDescriptor.value );\r\n  }\r\n\r\n}","import Identifier from './Identifier';\r\nimport Logger from './Logger';\r\nimport SuperExtensionManager from './SuperExtensionManager';\r\nimport AccessorDescriptorReplicator from './AccessorDescriptorReplicator';\r\nimport DataDescriptorReplicator from './DataDescriptorReplicator';\r\n\r\nexport default class Cloner {\r\n\r\n  static extend( hostObject, extensionObject, config, ...extensionConstructorArgs ) {\r\n    if ( Identifier.isConstructorFunction( extensionObject ) )\r\n      return Cloner.extendFromConstructorFunction( hostObject, extensionObject,\r\n        config, ...extensionConstructorArgs );\r\n    if ( Identifier.isProtoype( extensionObject ) )\r\n      return Cloner.extendFromPrototype( hostObject, extensionObject,\r\n        config, ...extensionConstructorArgs );\r\n    return false;\r\n  }\r\n\r\n  static extendFromInstance( hostObject, extensionInstance, config, ...extensionConstructorArgs ) {\r\n    if ( !Identifier.isObject( extensionInstance ) ) return false;\r\n    if ( Identifier.isConstructorFunction( extensionInstance.constructor ) )\r\n      return Cloner.extendFromConstructorFunction( hostObject,\r\n        extensionInstance.constructor, config, ...extensionConstructorArgs );\r\n    return Cloner.extendFromPrototype( hostObject,\r\n      Object.getPrototypeOf( extensionInstance ),\r\n      config, ...extensionConstructorArgs );\r\n  }\r\n\r\n  static extendFromPrototype( hostObject, extensionObject, config, ...extensionConstructorArgs ) {\r\n    if ( !Identifier.isObject( hostObject ) )\r\n      return Logger.trace( `Could not extend an invalid object.`, null, false );\r\n    if ( !Identifier.isProtoype( extensionObject ) )\r\n      return Logger.trace( `Could not extend an object by an invalid extension.`,\r\n        null, false );\r\n    const hasConfig = Identifier.isObject( config );\r\n    if ( !hasConfig || !!config.register ) {\r\n      SuperExtensionManager.registerInstance( hostObject, extensionObject );\r\n      SuperExtensionManager.addSuperMethod( hostObject );\r\n    }\r\n    const accessorDescriptorPropertiesMirrored = hasConfig &&\r\n      !config.mirrorGettersAndSetters ? true : AccessorDescriptorReplicator\r\n      .mirrorGettersAndSettersFromPrototypeOnWholePrototypeChain( {\r\n        hostObject: hostObject,\r\n        prototype: extensionObject,\r\n        override: !hasConfig ? false : !!config.overrideGettersAndSetters\r\n      } );\r\n    const dataDescriptorPropertiesMirrored = DataDescriptorReplicator\r\n      .mirrorDataDescriptorsFromPrototypeOnWholePrototypeChain( {\r\n        hostObject: hostObject,\r\n        prototype: extensionObject,\r\n        mirrorFunctions: !hasConfig ? true : !!config.mirrorFunctions,\r\n        mirrorOthers: !hasConfig ? true : !!config.mirrorOthers,\r\n        overrideFunctions: !hasConfig ? false : !!config.overrideFunctions,\r\n        overrideOthers: !hasConfig ? false : !!config.overrideOthers\r\n      } );\r\n    return accessorDescriptorPropertiesMirrored &&\r\n      dataDescriptorPropertiesMirrored;\r\n  }\r\n\r\n  static extendFromConstructorFunction( hostObject, extensionObject, config, ...extensionConstructorArgs ) {\r\n    if ( !Identifier.isObject( hostObject ) )\r\n      return Logger.trace( `Could not extend an invalid object.`, null, false );\r\n    if ( !Identifier.isConstructorFunction( extensionObject ) )\r\n      return Logger.trace( `Could not extend an object by an invalid extension.`,\r\n        null, false );\r\n    const hasConfig = Identifier.isObject( config );\r\n    if ( !hasConfig || !!config.register ) {\r\n      SuperExtensionManager.registerInstance( hostObject, extensionObject );\r\n      SuperExtensionManager.addSuperMethod( hostObject );\r\n    }\r\n    const accessorDescriptorPropertiesMirrored = hasConfig &&\r\n      !config.mirrorGettersAndSetters ? true : AccessorDescriptorReplicator\r\n      .mirrorGettersAndSettersFromInstanceOnWholePrototypeChain( {\r\n        hostObject: hostObject,\r\n        instance: new extensionObject( ...extensionConstructorArgs ),\r\n        override: !hasConfig ? false : !!config.overrideGettersAndSetters\r\n      } );\r\n    const dataDescriptorPropertiesMirrored = DataDescriptorReplicator\r\n      .mirrorDataDescriptorsFromInstanceOnWholePrototypeChain( {\r\n        hostObject: hostObject,\r\n        instance: new extensionObject( ...extensionConstructorArgs ),\r\n        mirrorFunctions: !hasConfig ? true : !!config.mirrorFunctions,\r\n        mirrorOthers: !hasConfig ? true : !!config.mirrorOthers,\r\n        overrideFunctions: !hasConfig ? false : !!config.overrideFunctions,\r\n        overrideOthers: !hasConfig ? false : !!config.overrideOthers\r\n      } );\r\n    return accessorDescriptorPropertiesMirrored &&\r\n      dataDescriptorPropertiesMirrored;\r\n  }\r\n\r\n  static classFunctionToInstance( classFunction ) {\r\n    if ( !( classFunction instanceof Function ) ||\r\n      !Identifier.isFunction( classFunction.constructor ) )\r\n      return void 0;\r\n    let instance = void 0;\r\n    try {\r\n      instance = new classFunction();\r\n    } catch ( error ) {}\r\n    return instance;\r\n  }\r\n\r\n  static getClonablePropertyDescriptor( {\r\n    hostObject,\r\n    prototype,\r\n    propertyName,\r\n    override = false\r\n  } ) {\r\n    if ( !Identifier.isObject( hostObject ) ||\r\n      !Identifier.isObject( prototype ) ||\r\n      !Identifier.isString( propertyName ) ||\r\n      !( propertyName in prototype ) ) return void 0;\r\n    if ( propertyName in hostObject ) {\r\n      if ( !override ) return void 0;\r\n      const hostObjectDescriptor =\r\n        Object.getOwnPropertyDescriptor( hostObject, propertyName );\r\n      if ( !hostObjectDescriptor.configurable )\r\n        return Logger.trace( `The property ${ propertyName } is not` +\r\n          ` configurable and could not be mirrored on the object.`, null, void 0 );\r\n      delete hostObject[ propertyName ];\r\n    } else if ( !Object.isExtensible( hostObject ) )\r\n      return Logger.trace( `Could not assign the property ${ propertyName }` +\r\n        ` to a non extensible object.`, null, void 0 );\r\n    return Object.getOwnPropertyDescriptor( prototype, propertyName );\r\n  }\r\n\r\n}","export class Mammal {\r\n\r\n  constructor( weight ) {\r\n    Object.defineProperty( this, \"_weight\", {\r\n      value: weight,\r\n      writable: true,\r\n      configurable: true,\r\n      enumarable: false\r\n    } );\r\n  }\r\n\r\n  get weight() {\r\n    return this._weight;\r\n  }\r\n\r\n  eat() {}\r\n\r\n}\r\n\r\nexport class Human extends Mammal {\r\n\r\n  constructor( name, age, weight ) {\r\n    super( weight );\r\n    this._name = name;\r\n  }\r\n\r\n  get name() {\r\n    return this._name;\r\n  }\r\n\r\n  breathe() {}\r\n\r\n}\r\n\r\nexport default class Student extends Human {\r\n\r\n  constructor( name, age ) {\r\n    super( name, age );\r\n    this._credits = 0;\r\n  }\r\n\r\n  addCredits( amountOfCreditsToAdd ) {\r\n    this._credits += amountOfCreditsToAdd;\r\n  }\r\n\r\n  get credits() {\r\n    return this._credits;\r\n  }\r\n\r\n}","import Logger from '../src/Logger';\r\nimport {\r\n  Human\r\n} from './Student';\r\n\r\nexport class Scientist extends Human {\r\n\r\n  constructor( name, age ) {\r\n    super( name, age );\r\n  }\r\n\r\n  get skillSet() {\r\n    return void 0;\r\n  }\r\n\r\n  get education() {\r\n    return void 0;\r\n  }\r\n\r\n  contact() {}\r\n\r\n}\r\n\r\nexport default class Informatician extends Scientist {\r\n\r\n  constructor( name, age ) {\r\n    super( name, age );\r\n  }\r\n\r\n  get experience() {\r\n    return void 0;\r\n  }\r\n\r\n  readCode() {}\r\n\r\n  writeCode() {}\r\n\r\n  work( taskName, hours ) {\r\n    Logger.trace( taskName + \" \" + hours );\r\n  }\r\n\r\n}","import Cloner from './Cloner';\r\nimport Identifier from './Identifier';\r\n\r\nexport default class Extension {\r\n\r\n  constructor( hostObject, config = void 0 ) {\r\n    if ( Identifier.isObject( hostObject ) )\r\n      Cloner.extendFromInstance( hostObject, this, config );\r\n  }\r\n\r\n}","import Extension from '../src/Extension';\r\n\r\nexport default class WorkingProfessional extends Extension {\r\n\r\n  constructor( hostObject ) {\r\n    super( hostObject );\r\n    this._salary = void 0;\r\n  }\r\n\r\n  get salary() {\r\n    return this._salary;\r\n  }\r\n\r\n  set salary( newSalary ) {\r\n    this._salary = newSalary;\r\n  }\r\n\r\n  startVacation() {}\r\n\r\n  static isExtension() {\r\n    return true;\r\n  }\r\n\r\n}","import Cloner from '../src/Cloner';\r\nimport Extension from '../src/Extension';\r\nimport Identifier from '../src/Identifier';\r\nimport Logger from '../src/Logger';\r\nimport {\r\n  Mammal\r\n} from './Student';\r\nimport Student from './Student';\r\nimport Informatician from './Informatician';\r\nimport Scientist from './Informatician';\r\nimport AccessorDescriptorReplicator from '../src/AccessorDescriptorReplicator';\r\nimport WorkingProfessional from './WorkingProfessional';\r\n\r\nvar Random = class extends Student {};\r\n\r\nexport class InformaticsStudent extends Student {\r\n\r\n  #private() {\r\n    Logger.trace();\r\n  }\r\n\r\n  constructor( name, age ) {\r\n    // Object.defineProperty( InformaticsStudent, Symbol.hasInstance, {\r\n    //   value: function( leftHandOperand ) {\r\n    //     return Identifier.instanceof( leftHandOperand, InformaticsStudent, false );\r\n    //   }\r\n    // } );\r\n    super( name, age );\r\n    // Cloner.extend( this, Informatician, null, name, age );\r\n    new WorkingProfessional( this );\r\n    this.abc;\r\n    new Random();\r\n    delete this.eat;\r\n    this.eat();\r\n    // console.log( this.instanceof( Informatician ) );\r\n    // console.log( this.instanceof( Scientist ) );\r\n    // console.log( this.instanceof( WorkingProfessional ) );\r\n    // console.log( this instanceof Extension );\r\n    // this.work( \"TaskA\", 5 );\r\n    // this.#private();\r\n  }\r\n\r\n  work( taskName, hours ) {\r\n    console.log( super.age );\r\n    try {\r\n      this.#private();\r\n    } catch ( err ) {\r\n      Logger.trace( ``, err );\r\n    }\r\n    super.eat();\r\n    this.super( \"work\", taskName, hours );\r\n  }\r\n\r\n  // static[ Symbol.hasInstance ]( leftHandOperand ) {\r\n  //   return Identifier.instanceof( leftHandOperand, InformaticsStudent, false );\r\n  // }\r\n\r\n}\r\n\r\nCloner.extend( InformaticsStudent.prototype, Informatician, null );\r\nnew WorkingProfessional( InformaticsStudent.prototype );\r\n\r\nexport class StudentOfInformatics extends Informatician {\r\n\r\n  constructor( name, age ) {\r\n    super( name, age );\r\n    Cloner.extendFromInstance( this, new Student(), null, name, age );\r\n    // console.log( this.instanceof( Informatician ) );\r\n    // console.log( this.instanceof( Student ) );\r\n  }\r\n\r\n}\r\n\r\nexport class StudentInformatician {\r\n\r\n  constructor( name, age ) {\r\n    let a = new InformaticsStudent();\r\n    Cloner.extend( this, InformaticsStudent, null, name, age );\r\n    // Cloner.extend( this, new Informatician(), null, name, age );\r\n    // Cloner.extend( this, new Student(), null, name, age, faculty );\r\n    // console.log( this.instanceof( Informatician ) );\r\n    // console.log( this.instanceof( Student ) );\r\n    console.log( this.instanceof( WorkingProfessional ) );\r\n    console.log( this instanceof InformaticsStudent );\r\n    console.log( this instanceof WorkingProfessional );\r\n    console.log( this instanceof Student );\r\n    console.log( a instanceof WorkingProfessional );\r\n    console.log( a instanceof InformaticsStudent );\r\n    this.work( \"TaskA\", 5 );\r\n  }\r\n\r\n}","'use strict';\r\n\r\nimport {\r\n  InformaticsStudent,\r\n  StudentOfInformatics,\r\n  StudentInformatician\r\n} from './test/InformaticsStudent';\r\n\r\nfunction registerTestObjects() {\r\n  Object.defineProperty( window, \"inheritanceImitator\", {\r\n    value: {},\r\n    configurable: false,\r\n    enumerable: false\r\n  } );\r\n  window.inheritanceImitator.studentA = new InformaticsStudent();\r\n  window.inheritanceImitator.studentB = new StudentOfInformatics();\r\n  window.inheritanceImitator.studentC = new StudentInformatician();\r\n}\r\n\r\nregisterTestObjects();"],"names":[],"sourceRoot":""}